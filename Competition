#pragma config(Sensor, in1,    IntakePotentiometer, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           leftArm,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftFront,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           rightFront,    tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           leftBack,      tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           rightBack,     tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port6,           leftIntake,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightIntake,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           claw,          tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           arm2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightArm,      tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


void driveTrainForward(int distanceForward, int power) {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[leftEncoder] < distanceForward) {
		motor[leftFront] = power;
		motor[rightFront] = power;
		motor[leftBack] = power;
		motor[rightBack] = power;
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}
void driveTrainBackward(int distanceBackward, int power) {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[leftEncoder] > distanceBackward) {
		motor[leftFront] = -power;
		motor[rightFront] = -power;
		motor[leftBack] = -power;
		motor[rightBack] = -power;
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}
void pointTurnLeft (int leftTurnDistance, int power) {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[leftEncoder] > leftTurnDistance) {
		motor[leftFront] = -power;
		motor[leftBack] = -power;
		motor[rightFront] = power;
		motor[rightBack] = power;
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}
void pointTurnRight (int rightTurnDistance, int power) {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[leftEncoder] < rightTurnDistance) {
		motor[leftFront] = power;
		motor[leftBack] = power;
		motor[rightFront] = -power;
		motor[rightBack] = -power;
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}
void swerveTurnLeft (int leftSwerveDistance, int power) {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[leftEncoder] > leftSwerveDistance) {
		motor[leftFront] = power;
		motor[leftBack] = power;
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}
void swerveTurnRight (int rightSwerveDistance, int power) {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[rightEncoder] < rightSwerveDistance) {
		motor[rightFront] = power;
		motor[rightBack] = power;
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}
void intakeDown (int power) {
	while (SensorValue[IntakePotentiometer] < 1600) {
		motor[leftIntake] = power;
		motor[rightIntake] = power;
	}
	motor[leftIntake] = 0;
	motor[rightIntake] = 0;
}
void intakeUp (int power) {
	while (SensorValue[IntakePotentiometer] > 200) {
		motor[leftIntake] = -power;
		motor[rightIntake] = -power;
	}
	motor[leftIntake] = 0;
	motor[rightIntake] = 0;
}

// Declare count variable to keep track of our choice (LCD)
int count = 0;

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------


void pre_auton()
{
	bStopTasksBetweenModes = true;

	// Clear Encoders
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	//------------- Beginning of User Interface Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Loop while center button is not pressed
	while(nLCDButtons != centerButton)
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Stationary");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 3;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "10 Pt. Auton");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "20 Point");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "7 Pt. Auton");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count = 0;
			break;
		}
	}
}


task autonomous()
{
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Stationary Auton");
		displayLCDCenteredString(1, "is running!");

		// Stationary Auton:

		setMotor(-90, claw);
		setMultipleMotors(80, rightArm, leftArm);
		while (SensorValue[leftEncoder] < 791) {
			motor[rightFront] = 60;
			motor[leftFront] = 60;
			motor[rightBack] = 60;
			motor[leftBack] = 60;
		}
		stopMultipleMotors(rightArm, leftArm);
		stopMotor(claw);
		setMotor(90, claw);
		wait(1, seconds);
		while (SensorValue[leftEncoder] > 400) {
			motor[rightFront] = -60;
			motor[leftFront] = -60;
			motor[rightBack] = -60;
			motor[leftBack] = -60;
		}
		stopMotor(claw);
		turnRight(1, seconds, 50);
		setMultipleMotors(95, port6, port7);
		wait(1, seconds);
		stopMultipleMotors(port6, port7);
		forward(3, seconds, 60);
		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "10 Pt. Auton");
		displayLCDCenteredString(1, "is running!");

		// 10 Pt. Auton:

		// Keep arm up
		setMultipleMotors(40, rightArm, leftArm);
		// Put Intake Down
		intakeDown(127);
		// Move Forward Into Mobile Goal
		driveTrainForward(1262, 80);
		// Intake Mobile Goal
		intakeUp(100);
		// Reset Encoder Values
		SensorValue[rightEncoder] = 0;
		SensorValue[leftEncoder] = 0;
		// Move Backwards
		driveTrainBackward(-903, 90);
		// Reset Encoder Values
		SensorValue[rightEncoder] = 0;
		SensorValue[leftEncoder] = 0;
		// Turn, Please Get Encoder Values
		turnLeft(1.5, seconds, 65);
		// Reset Encoder Values
		SensorValue[rightEncoder] = 0;
		SensorValue[leftEncoder] = 0;
		// Forward into 20 point zone
		forward(1.25, seconds, 90);
		// Put mobile goal in zone
		intakeDown(127);
		// Go backwards
		backward(1, seconds, 80);
		// Stop Arm
		stopMultipleMotors(rightArm, leftArm);

		// Insert Autonomous 2
		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "20 Pt. Auton");
		displayLCDCenteredString(1, "is running!");

		// 20 Pt. Auton:

		// Keep arm up
		setMultipleMotors(40, rightArm, leftArm);
		// Put Intake Down
		intakeDown(127);
		// Move Forward Into Mobile Goal
		driveTrainForward(1262, 80);
		// Intake Mobile Goal
		intakeUp(100);
		// Reset Encoder Values
		SensorValue[rightEncoder] = 0;
		SensorValue[leftEncoder] = 0;
		// Move Backwards
		driveTrainBackward(-903, 90);
		// Reset Encoder Values
		SensorValue[rightEncoder] = 0;
		SensorValue[leftEncoder] = 0;
		// Turn, Please Get Encoder Values
		turnLeft(1.5, seconds, 65);
		// Reset Encoder Values
		SensorValue[rightEncoder] = 0;
		SensorValue[leftEncoder] = 0;
		// Forward into 20 point zone
		forward(2.5, seconds, 90);
		// Put mobile goal in zone
		intakeDown(127);
		// Go backwards
		backward(2, seconds, 80);
		// Stop Arm
		stopMultipleMotors(rightArm, leftArm);

		break;
	case 3:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "7 Pt. Auton");
		displayLCDCenteredString(1, "is running!");

			// Lift the arm up
			setMultipleMotors(45, leftArm, rightArm);
			// Close the claw on the preloaded cone
			setMotor(claw, -80);
			// Allow the arm to raise before putting the intake down (wait for .5)
			delay(500);
			// Put the mobile goal intake down
			intakeDown(90);
			// Go forward into the mobile goal
			driveTrainForward(1290, 90);
			// Intake the mobile goal
			intakeUp(90);
			// Discontinue power to the arm, allow it to fall back down
			stopMultipleMotors(leftArm, rightArm);
			// Stop power to the claw
			stopMotor(claw);
			// Open the claw for .25 seconds at 80 power
			setMotor(claw, 80);
			wait1Msec(250);
			stopMotor(claw);
			// Put the arm back up
			setMultipleMotors(45, leftArm, rightArm);
			// Move the robot backwards
			driveTrainBackward(-967, 90);
			// Turn right facing the 5 pt zone
			pointTurnRight(615, 90);
			// Move forward into the 5 pt zone
			driveTrainForward(100, 90);
			// Put the mobile goal intake down
			intakeDown(90);
			// Move backwards away from scored mobile goal
			driveTrainBackward(-200, 90);

		break;
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
	}
}

task usercontrol()
{
	while (true)
	{
		// Drive Train Full Power/65%
		if (vexRT[Btn6U] == 1) {
			motor[rightFront] = 127;
			motor[rightBack] = 127;
		}
		else if (vexRT[Btn6D] == 1) {
			motor[rightFront] = -127;
			motor[rightBack] = -127;
		}
		else if (vexRT[Btn8U] == 1) {
			motor[rightFront] = 75;
			motor[rightBack] = 75;
		}
		else if (vexRT[Btn8D] == 1) {
			motor[rightFront] = -75;
			motor[rightBack] = -75;
		}
		else {
			motor[rightFront] = 0;
			motor[rightBack] = 0;
		}
		if (vexRT[Btn5U] == 1) {
			motor[leftFront] = 127;
			motor[leftBack] = 127;
		}
		else if (vexRT[Btn5D] == 1) {
			motor[leftFront] = -127;
			motor[leftBack] = -127;
		}
		else if (vexRT[Btn7U] == 1) {
			motor[leftFront] = 75;
			motor[leftBack] = 75;
		}
		else if (vexRT[Btn7D] == 1) {
			motor[leftFront] = -75;
			motor[leftBack] = -75;
		}
		else {
			motor[leftFront] = 0;
			motor[leftBack] = 0;
		}
		// Intake
		if (vexRT[Ch2] > 15) {
			motor[leftIntake] = vexRT[Ch2] * 0.75;
			motor[rightIntake] = vexRT[Ch2] * 0.75;
		}
		else if (vexRT[Ch2] < -15) {
			motor[leftIntake] = vexRT[Ch2] * 0.75;
			motor[rightIntake] = vexRT[Ch2] * 0.75;
		}
		else {
			motor[leftIntake] = 0;
			motor[rightIntake] = 0;
		}
		// Arm control
		if (vexRT[Ch2Xmtr2] > 15) {
			motor[leftArm] = vexRT[Ch2Xmtr2];
			motor[rightArm] = vexRT[Ch2Xmtr2];
		}
		else if (vexRT[Ch2Xmtr2] < -15) {
			motor[leftArm] = vexRT[Ch2Xmtr2];
			motor[rightArm] = vexRT[Ch2Xmtr2];
		}
		else {
			motor[leftArm] = 0;
			motor[rightArm] = 0;
		}
		// arm2 control
		if (vexRT[Ch3Xmtr2] > 15) {
			motor[arm2] = vexRT[Ch3Xmtr2];
		}
		else if (vexRT[Ch3Xmtr2] < -15) {
			motor[arm2] = vexRT[Ch3Xmtr2];
		}
		else {
			motor[arm2] = 0;
		}
		// Claw control
		if (vexRT[Btn5UXmtr2] == 1) {
			motor[claw] = 75;
		}
		else if (vexRT[Btn5DXmtr2] == 1) {
			motor[claw] = -75;
		}
		else {
			motor[claw] = 0;
		}
	}
}
